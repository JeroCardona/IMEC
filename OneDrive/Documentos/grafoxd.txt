from networkx.algorithms.traversal.breadth_first_search import breadth_first_search
import networkx as nx

# Definimos la matriz del laberinto
laberinto = [  [0, 0, 0, 0],
  [1, 1, 0, 1],
  [0, 0, 0, 0],
  [0, 1, 1, 0],
]

# Creamos un grafo vacío
Grafo = nx.Graph()

# Agregamos los nodos al grafo
for i in range(len(laberinto)):
    for j in range(len(laberinto[i])):
        if laberinto[i][j] == 0:
            Grafo.add_node((i, j))

# Agregamos las aristas al grafo
for i in range(len(laberinto)):
    for j in range(len(laberinto[i])):
        if laberinto[i][j] == 0:
            if i > 0 and laberinto[i-1][j] == 0:
                Grafo.add_edge((i, j), (i-1, j))
            if i < len(laberinto)-1 and laberinto[i+1][j] == 0:
                Grafo.add_edge((i, j), (i+1, j))
            if j > 0 and laberinto[i][j-1] == 0:
                Grafo.add_edge((i, j), (i, j-1))
            if j < len(laberinto[i])-1 and laberinto[i][j+1] == 0:
                Grafo.add_edge((i, j), (i, j+1))

# Recorremos el grafo por búsqueda por anchura
start_node = (0, 0)
goal_node = (3, 3)
path = list(breadth_first_search(Grafo, start_node))
if goal_node in path:
    print("El camino más corto al objetivo es:", path)
else:
    print("No se encontró un camino al objetivo.")